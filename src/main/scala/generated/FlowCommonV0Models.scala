/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.16.70
 * apibuilder 0.15.33 app.apibuilder.io/flow/common/latest/scala_models
 */
package io.flow.common.v0.models {

  trait IdReference {
    def id: String
  }
  sealed trait DiscountOffer extends _root_.scala.Product with _root_.scala.Serializable {
    def discountOfferDiscriminator: DiscountOfferDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type DiscountOffer
   */
  sealed trait DiscountOfferDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object DiscountOfferDiscriminator {

    case object DiscountOfferFixed extends DiscountOfferDiscriminator { override def toString = "discount_offer_fixed" }
    case object DiscountOfferPercent extends DiscountOfferDiscriminator { override def toString = "discount_offer_percent" }

    final case class UNDEFINED(override val toString: String) extends DiscountOfferDiscriminator

    val all: scala.List[DiscountOfferDiscriminator] = scala.List(DiscountOfferFixed, DiscountOfferPercent)

    private[this] val byName: Map[String, DiscountOfferDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DiscountOfferDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DiscountOfferDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ExpandableOrganization extends IdReference {
    def expandableOrganizationDiscriminator: ExpandableOrganizationDiscriminator
    def id: String

  }

  /**
   * Defines the valid discriminator values for the type ExpandableOrganization
   */
  sealed trait ExpandableOrganizationDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableOrganizationDiscriminator {

    case object Organization extends ExpandableOrganizationDiscriminator { override def toString = "organization" }
    case object OrganizationReference extends ExpandableOrganizationDiscriminator { override def toString = "organization_reference" }

    final case class UNDEFINED(override val toString: String) extends ExpandableOrganizationDiscriminator

    val all: scala.List[ExpandableOrganizationDiscriminator] = scala.List(Organization, OrganizationReference)

    private[this] val byName: Map[String, ExpandableOrganizationDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableOrganizationDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableOrganizationDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ExpandableUser extends IdReference {
    def expandableUserDiscriminator: ExpandableUserDiscriminator
    def id: String

  }

  /**
   * Defines the valid discriminator values for the type ExpandableUser
   */
  sealed trait ExpandableUserDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableUserDiscriminator {

    case object User extends ExpandableUserDiscriminator { override def toString = "user" }
    case object UserReference extends ExpandableUserDiscriminator { override def toString = "user_reference" }

    final case class UNDEFINED(override val toString: String) extends ExpandableUserDiscriminator

    val all: scala.List[ExpandableUserDiscriminator] = scala.List(User, UserReference)

    private[this] val byName: Map[String, ExpandableUserDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableUserDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableUserDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait InputSpecificationLimitation extends _root_.scala.Product with _root_.scala.Serializable {
    def inputSpecificationLimitationDiscriminator: InputSpecificationLimitationDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type InputSpecificationLimitation
   */
  sealed trait InputSpecificationLimitationDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object InputSpecificationLimitationDiscriminator {

    case object InputSpecificationLimitationMax extends InputSpecificationLimitationDiscriminator { override def toString = "input_specification_limitation_max" }

    final case class UNDEFINED(override val toString: String) extends InputSpecificationLimitationDiscriminator

    val all: scala.List[InputSpecificationLimitationDiscriminator] = scala.List(InputSpecificationLimitationMax)

    private[this] val byName: Map[String, InputSpecificationLimitationDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): InputSpecificationLimitationDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[InputSpecificationLimitationDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Logos should be rendered in a size that best fits the user's device and
   * viewport. Some images formats can be resized natively by UI applications, but
   * others require separate image links for each one.
   */
  sealed trait LogoImage extends _root_.scala.Product with _root_.scala.Serializable {
    def logoImageDiscriminator: LogoImageDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type LogoImage
   */
  sealed trait LogoImageDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object LogoImageDiscriminator {

    case object LogoImageSvg extends LogoImageDiscriminator { override def toString = "svg" }
    case object LogoImageSetStatic extends LogoImageDiscriminator { override def toString = "static" }

    final case class UNDEFINED(override val toString: String) extends LogoImageDiscriminator

    val all: scala.List[LogoImageDiscriminator] = scala.List(LogoImageSvg, LogoImageSetStatic)

    private[this] val byName: Map[String, LogoImageDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LogoImageDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LogoImageDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait PriceSource extends _root_.scala.Product with _root_.scala.Serializable {
    def priceSourceDiscriminator: PriceSourceDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type PriceSource
   */
  sealed trait PriceSourceDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object PriceSourceDiscriminator {

    case object PriceSourcePriceBook extends PriceSourceDiscriminator { override def toString = "price_book" }
    case object PriceSourceCatalog extends PriceSourceDiscriminator { override def toString = "catalog" }
    case object PriceSourceProvided extends PriceSourceDiscriminator { override def toString = "provided" }

    final case class UNDEFINED(override val toString: String) extends PriceSourceDiscriminator

    val all: scala.List[PriceSourceDiscriminator] = scala.List(PriceSourcePriceBook, PriceSourceCatalog, PriceSourceProvided)

    private[this] val byName: Map[String, PriceSourceDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PriceSourceDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PriceSourceDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait RepeatSchedule extends _root_.scala.Product with _root_.scala.Serializable {
    def repeatScheduleDiscriminator: RepeatScheduleDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type RepeatSchedule
   */
  sealed trait RepeatScheduleDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object RepeatScheduleDiscriminator {

    case object RepeatHourly extends RepeatScheduleDiscriminator { override def toString = "repeat_hourly" }
    case object RepeatDaily extends RepeatScheduleDiscriminator { override def toString = "repeat_daily" }
    case object RepeatWeekly extends RepeatScheduleDiscriminator { override def toString = "repeat_weekly" }
    case object RepeatMonthly extends RepeatScheduleDiscriminator { override def toString = "repeat_monthly" }

    final case class UNDEFINED(override val toString: String) extends RepeatScheduleDiscriminator

    val all: scala.List[RepeatScheduleDiscriminator] = scala.List(RepeatHourly, RepeatDaily, RepeatWeekly, RepeatMonthly)

    private[this] val byName: Map[String, RepeatScheduleDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): RepeatScheduleDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[RepeatScheduleDiscriminator] = byName.get(value.toLowerCase)

  }
  /**
   * Defines structured fields for address to be used in user/form input. Either text
   * or the structured input needs to be present.
   *
   * @param text Full text version of address
   * @param streets Array for street line 1, street line 2, etc., in order
   * @param streetNumber The specific street number, if available.
   * @param country The ISO 3166-3 country code. Case insensitive. See
   *        https://api.flow.io/reference/countries
   */

  final case class Address(
    text: _root_.scala.Option[String] = None,
    streets: _root_.scala.Option[Seq[String]] = None,
    streetNumber: _root_.scala.Option[String] = None,
    city: _root_.scala.Option[String] = None,
    province: _root_.scala.Option[String] = None,
    postal: _root_.scala.Option[String] = None,
    country: _root_.scala.Option[String] = None,
    latitude: _root_.scala.Option[String] = None,
    longitude: _root_.scala.Option[String] = None
  )

  /**
   * @param name The name of the customer associated with the billing address
   * @param streets Array for street line 1, street line 2, etc., in order
   * @param country The ISO 3166-3 country code. Case insensitive. See
   *        https://api.flow.io/reference/countries
   * @param company Business entity or organization name of this contact
   */

  final case class BillingAddress(
    name: _root_.scala.Option[io.flow.common.v0.models.Name] = None,
    streets: _root_.scala.Option[Seq[String]] = None,
    city: _root_.scala.Option[String] = None,
    province: _root_.scala.Option[String] = None,
    postal: _root_.scala.Option[String] = None,
    country: _root_.scala.Option[String] = None,
    company: _root_.scala.Option[String] = None
  )

  final case class CatalogItemReference(
    id: String,
    number: String
  )

  final case class CatalogItemSummary(
    number: String,
    name: String,
    attributes: Map[String, String]
  )

  final case class ChannelReference(
    id: String
  )

  final case class CheckoutReference(
    id: String
  )

  /**
   * Defines structured fields for a contact person. Typically used for specifying
   * contact person for an account, shipment, or organization representative
   *
   * @param name Personal information of point-of-contact
   * @param company Business entity or organization name of this contact
   */

  final case class Contact(
    name: io.flow.common.v0.models.Name,
    company: _root_.scala.Option[String] = None,
    email: _root_.scala.Option[String] = None,
    phone: _root_.scala.Option[String] = None
  )

  /**
   * @param address The address to be used for invoicing and harmonization.
   */

  final case class CustomerInvoice(
    address: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None
  )

  /**
   * @param number Customer identification number as represented in the client's system
   */

  final case class CustomerReference(
    number: String
  )

  final case class DatetimeRange(
    from: _root_.org.joda.time.DateTime,
    to: _root_.org.joda.time.DateTime
  )

  final case class Dimension(
    depth: _root_.scala.Option[io.flow.common.v0.models.Measurement] = None,
    diameter: _root_.scala.Option[io.flow.common.v0.models.Measurement] = None,
    length: _root_.scala.Option[io.flow.common.v0.models.Measurement] = None,
    weight: _root_.scala.Option[io.flow.common.v0.models.Measurement] = None,
    width: _root_.scala.Option[io.flow.common.v0.models.Measurement] = None
  )

  final case class Dimensions(
    product: _root_.scala.Option[io.flow.common.v0.models.Dimension] = None,
    packaging: _root_.scala.Option[io.flow.common.v0.models.Dimension] = None
  )

  /**
   * @param target Indicates the target of the discount.
   * @param label Label to display (e.g. the discount code). Discounts with the same label
   *        represent aggregated offers.
   */

  final case class DiscountForm(
    offer: io.flow.common.v0.models.DiscountOffer,
    target: io.flow.common.v0.models.DiscountTarget = io.flow.common.v0.models.DiscountTarget.Item,
    label: _root_.scala.Option[String] = None
  )

  final case class DiscountOfferFixed(
    money: io.flow.common.v0.models.Money
  ) extends DiscountOffer {
    override val discountOfferDiscriminator: DiscountOfferDiscriminator = DiscountOfferDiscriminator.DiscountOfferFixed
  }

  final case class DiscountOfferPercent(
    percent: BigDecimal
  ) extends DiscountOffer {
    override val discountOfferDiscriminator: DiscountOfferDiscriminator = DiscountOfferDiscriminator.DiscountOfferPercent
  }

  final case class DiscountsForm(
    discounts: Seq[io.flow.common.v0.models.DiscountForm]
  )

  /**
   * Represents a duration of time.
   */

  final case class Duration(
    unit: io.flow.common.v0.models.UnitOfTime,
    value: Long
  )

  /**
   * Tax identifier could be associated to a merchant of record entity.
   *
   * @param issuingCountry The country that issued this identifier. Should be an ISO 3166-3 country code.
   */

  final case class EntityIdentifier(
    name: io.flow.common.v0.models.EntityIdentifierType,
    number: String,
    issuingCountry: _root_.scala.Option[String] = None
  )

  /**
   * Represents an exception to the schedule of a center.
   *
   * @param datetimeRange Range for the holiday. For single-day holidays, from and to should just be the
   *        same.
   */

  final case class Exception(
    `type`: io.flow.common.v0.models.ExceptionType,
    datetimeRange: io.flow.common.v0.models.DatetimeRange
  )

  /**
   * Some important fields related to experiences used in various APIs
   *
   * @param country ISO 3166 3 currency code as defined in https://api.flow.io/reference/countries
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages
   */

  final case class ExperienceSummary(
    id: String,
    key: String,
    name: String,
    country: _root_.scala.Option[String] = None,
    currency: _root_.scala.Option[String] = None,
    language: _root_.scala.Option[String] = None
  )

  /**
   * @param label The label for the included levies that can be displayed as a tooltip on the
   *        product detail page.
   */

  final case class IncludedLevies(
    key: io.flow.common.v0.models.IncludedLevyKey,
    label: String
  )

  final case class InputForm(
    values: _root_.scala.Option[Map[String, String]] = None
  )

  final case class InputFormSpecification(
    inputs: _root_.scala.Option[Seq[io.flow.common.v0.models.InputSpecification]] = None,
    limitations: _root_.scala.Option[io.flow.common.v0.models.InputSpecificationLimitations] = None
  )

  /**
   * @param displayText Text to display for this input.
   */

  final case class InputSpecification(
    `type`: io.flow.common.v0.models.InputSpecificationType,
    name: String,
    displayText: _root_.scala.Option[String] = None
  )

  /**
   * Represents the maximum number of accepted inputs
   */

  final case class InputSpecificationLimitationMax(
    max: Long
  ) extends InputSpecificationLimitation {
    override val inputSpecificationLimitationDiscriminator: InputSpecificationLimitationDiscriminator = InputSpecificationLimitationDiscriminator.InputSpecificationLimitationMax
  }

  final case class InputSpecificationLimitations(
    limitations: _root_.scala.Option[Seq[io.flow.common.v0.models.InputSpecificationLimitation]] = None
  )

  final case class ItemReference(
    number: String
  )

  /**
   * Line items represent the items a consumer is purchasing, including additional
   * information to complete the transaction. Note that you may pass in as many line
   * items as you like - including repeating item numbers across line items.
   *
   * @param price The price of this item for this order. If not specified, we will use the item
   *        price from the experience. Note that this price represents the price of a single
   *        line item - the total price to the consumer will be quantity * price.
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param center Optional center key associated with this item. Used for orders and quotes to
   *        specify where to ship an item from. If not specified, Flow will infer based on
   *        inventory setup.
   * @param discount The total discount, if any, to apply to this line item. Note that the discount
   *        is the total discount to apply regardless of the quantity here
   */

  final case class LineItem(
    number: String,
    quantity: Long,
    price: io.flow.common.v0.models.Money,
    attributes: Map[String, String],
    center: _root_.scala.Option[String] = None,
    discount: _root_.scala.Option[io.flow.common.v0.models.Money] = None
  )

  /**
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   */

  final case class LineItemAttributesForm(
    attributes: Map[String, String]
  )

  /**
   * Line items represent the items a consumer is purchasing, including additional
   * information to complete the transaction. Note that you may pass in as many line
   * items as you like - including repeating item numbers across line items.
   *
   * @param shipmentEstimate For items that may not immediately ship out from the origin because of different
   *        models of inventory (e.g. drop-ship, sell-first), this is a way for a client to
   *        communicate when the items can ship out. This will be used to calculate delivery
   *        option windows.
   * @param price The price of this item for this order. If not specified, we will use the item
   *        price from the experience
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param center Optional center key associated with this item. Used for orders and quotes to
   *        specify where to ship an item from. If not specified, Flow will infer based on
   *        inventory setup.
   * @param discount The total discount, if any, to apply to this line item. Note that the discount
   *        is the total discount to apply regardless of the quantity here
   * @param discounts The discounts, if any, to apply to this line item. Note that the discount is the
   *        total discount to apply regardless of the quantity here
   */

  final case class LineItemForm(
    number: String,
    quantity: Long,
    shipmentEstimate: _root_.scala.Option[io.flow.common.v0.models.DatetimeRange] = None,
    price: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    center: _root_.scala.Option[String] = None,
    discount: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    discounts: _root_.scala.Option[io.flow.common.v0.models.DiscountsForm] = None
  )

  final case class LineItemQuantityForm(
    quantity: Long
  )

  /**
   * Static images like png or jpeg must be provided in multiple sizes.
   */

  final case class LogoImageSetStatic(
    small: _root_.scala.Option[io.flow.common.v0.models.LogoImageStatic] = None,
    medium: io.flow.common.v0.models.LogoImageStatic,
    large: _root_.scala.Option[io.flow.common.v0.models.LogoImageStatic] = None
  ) extends LogoImage {
    override val logoImageDiscriminator: LogoImageDiscriminator = LogoImageDiscriminator.LogoImageSetStatic
  }

  final case class LogoImageStatic(
    url: String,
    width: Int,
    height: Int
  )

  /**
   * If the browser knows that an image is a svg, it can dynamically redraw the image
   * to different sizes
   */

  final case class LogoImageSvg(
    url: String
  ) extends LogoImage {
    override val logoImageDiscriminator: LogoImageDiscriminator = LogoImageDiscriminator.LogoImageSvg
  }

  final case class Margin(
    `type`: io.flow.common.v0.models.MarginType,
    value: BigDecimal
  )

  final case class Measurement(
    value: String,
    units: io.flow.common.v0.models.UnitOfMeasurement
  )

  /**
   * The merchant of record entity provides the legal name and address of the
   * specific Flow entity serving as merchant of record.
   *
   * @param identifiers Optionally additional issued tax identifiers associated to the entity.
   * @param streets Street Address Lines
   * @param country The ISO 3166-3 country code. Case insensitive. See
   *        https://api.flow.io/reference/countries
   * @param phone Primary customer service phone number for this entity
   * @param email Primary customer service email address for this entity
   */

  final case class MerchantOfRecordEntity(
    organization: io.flow.common.v0.models.OrganizationReference,
    name: String,
    vat: _root_.scala.Option[io.flow.common.v0.models.MerchantOfRecordEntityRegistration] = None,
    identifiers: _root_.scala.Option[Seq[io.flow.common.v0.models.EntityIdentifier]] = None,
    streets: Seq[String],
    city: String,
    province: _root_.scala.Option[String] = None,
    postal: _root_.scala.Option[String] = None,
    country: String,
    phone: _root_.scala.Option[String] = None,
    email: _root_.scala.Option[String] = None
  )

  /**
   * @param number In Europe, this is the VAT registration number for the entity. In the US, this
   *        is the EIN.
   * @param country The country in which this registration number is defined. The ISO 3166-3 country
   *        code. Case insensitive. See https://api.flow.io/reference/countries
   */

  final case class MerchantOfRecordEntityRegistration(
    number: String,
    country: String
  )

  /**
   * Money represents an amount in a given currency
   *
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   */

  final case class Money(
    amount: Double,
    currency: String
  )

  /**
   * @param currency Iso 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   */

  final case class MoneyWithBase(
    currency: String,
    amount: Double,
    base: io.flow.common.v0.models.Money
  )

  /**
   * Used to migrate older models to have a base value, without breaking
   * compatibility
   *
   * @param currency Iso 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   */

  final case class MoneyWithOptionalBase(
    currency: String,
    amount: Double,
    base: _root_.scala.Option[io.flow.common.v0.models.Money] = None
  )

  final case class Name(
    first: _root_.scala.Option[String] = None,
    last: _root_.scala.Option[String] = None
  )

  /**
   * A customer represents the actual person purchasing from you. This information is
   * needed primarily to support logistics (delivery to this person), fraud
   * management (verification of who the person is), and reporting. We also recommend
   * including your customer number whenever possible as doing so will allow Flow to
   * link up transactions for this customer making customer service easier.
   *
   * @param phone Customer phone number. Useful for both fraud and order delivery.
   * @param email Customer email address. Useful for fraud.
   * @param invoice Customer invoice details.
   */

  final case class OrderCustomer(
    name: io.flow.common.v0.models.Name,
    number: _root_.scala.Option[String] = None,
    phone: _root_.scala.Option[String] = None,
    email: _root_.scala.Option[String] = None,
    address: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    invoice: _root_.scala.Option[io.flow.common.v0.models.CustomerInvoice] = None
  )

  /**
   * @param phone Customer phone number. Useful for both fraud and order delivery.
   * @param email Customer email address. Useful for fraud.
   * @param invoice Customer invoice details.
   */

  final case class OrderCustomerForm(
    name: _root_.scala.Option[io.flow.common.v0.models.Name] = None,
    number: _root_.scala.Option[String] = None,
    phone: _root_.scala.Option[String] = None,
    email: _root_.scala.Option[String] = None,
    address: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    invoice: _root_.scala.Option[io.flow.common.v0.models.CustomerInvoice] = None
  )

  /**
   * Represents a single organization in the system, and what environment it is
   * currently operating in.
   *
   * @param parent When creating an organization in the test environment, it is linked to your
   *        production organization. This allows you to have as many test organizations as
   *        you like.
   * @param defaults Always present. Marked optional for backwards compatibility.
   */

  final case class Organization(
    override val id: String,
    name: String,
    environment: io.flow.common.v0.models.Environment,
    parent: _root_.scala.Option[io.flow.common.v0.models.OrganizationReference] = None,
    defaults: _root_.scala.Option[io.flow.common.v0.models.OrganizationDefaults] = None,
    createdAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    status: io.flow.common.v0.models.OrganizationStatus = io.flow.common.v0.models.OrganizationStatus.Active
  ) extends ExpandableOrganization {
    override val expandableOrganizationDiscriminator: ExpandableOrganizationDiscriminator = ExpandableOrganizationDiscriminator.Organization
  }

  /**
   * @param country The ISO 3166-3 country code. Case insensitive. See
   *        https://api.flow.io/reference/countries
   * @param baseCurrency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages
   * @param locale The locale id as defined in https://api.flow.io/reference/locales
   * @param timezone The name of the timezone as defined in https://api.flow.io/reference/timezones
   */

  final case class OrganizationDefaults(
    country: String,
    baseCurrency: String,
    language: String,
    locale: String,
    timezone: String
  )

  final case class OrganizationReference(
    override val id: String
  ) extends ExpandableOrganization {
    override val expandableOrganizationDiscriminator: ExpandableOrganizationDiscriminator = ExpandableOrganizationDiscriminator.OrganizationReference
  }

  final case class OrganizationSummary(
    id: String,
    name: String,
    environment: io.flow.common.v0.models.Environment
  )

  final case class PartnerReference(
    id: String
  )

  /**
   * Represents an amount-currency pair for a basic price
   *
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   */

  final case class Price(
    amount: Double,
    currency: String,
    label: String
  )

  /**
   * Amount-currency paid for a basic price to be used in model forms, before a price
   * label is created. Label in the main price model is created by the implementing
   * api.
   *
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   */

  final case class PriceForm(
    amount: Double,
    currency: String
  )

  /**
   * @param price Catalog item price.
   */

  final case class PriceSourceCatalog(
    price: io.flow.common.v0.models.Money
  ) extends PriceSource {
    override val priceSourceDiscriminator: PriceSourceDiscriminator = PriceSourceDiscriminator.PriceSourceCatalog
  }

  /**
   * @param price Price book item price.
   * @param includes Describes which levies are included in the price book price.
   */

  final case class PriceSourcePriceBook(
    price: io.flow.common.v0.models.Money,
    includes: io.flow.common.v0.models.IncludedLevies,
    priceBookReference: io.flow.common.v0.models.PriceSourcePriceBookReference
  ) extends PriceSource {
    override val priceSourceDiscriminator: PriceSourceDiscriminator = PriceSourceDiscriminator.PriceSourcePriceBook
  }

  final case class PriceSourcePriceBookReference(
    id: String,
    key: String
  )

  /**
   * @param price Provided item price.
   */

  final case class PriceSourceProvided(
    price: io.flow.common.v0.models.Money
  ) extends PriceSource {
    override val priceSourceDiscriminator: PriceSourceDiscriminator = PriceSourceDiscriminator.PriceSourceProvided
  }

  /**
   * @param currency Iso 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param label The localized label of the amount and currency
   */

  final case class PriceWithBase(
    currency: String,
    amount: Double,
    label: String,
    base: _root_.scala.Option[io.flow.common.v0.models.Price] = None
  )

  final case class RepeatDaily(
    interval: Int
  ) extends RepeatSchedule {
    override val repeatScheduleDiscriminator: RepeatScheduleDiscriminator = RepeatScheduleDiscriminator.RepeatDaily
  }

  final case class RepeatHourly(
    interval: Int
  ) extends RepeatSchedule {
    override val repeatScheduleDiscriminator: RepeatScheduleDiscriminator = RepeatScheduleDiscriminator.RepeatHourly
  }

  /**
   * Monthly on the {day} of each {interval} month. Note if you specify a day > 28
   * and the month does not have that day, the repeat schedule is assumed to be the
   * last day of the month. Common examples are: Monthly on the 1st, monthly on the
   * 15th and 31st, every 3 months on the 1st, etc.
   *
   * @param days A list of the days of the month on which to trigger the schedule
   */

  final case class RepeatMonthly(
    interval: Int,
    days: Seq[Int]
  ) extends RepeatSchedule {
    override val repeatScheduleDiscriminator: RepeatScheduleDiscriminator = RepeatScheduleDiscriminator.RepeatMonthly
  }

  final case class RepeatWeekly(
    interval: Int,
    daysOfWeek: Seq[io.flow.common.v0.models.DayOfWeek]
  ) extends RepeatSchedule {
    override val repeatScheduleDiscriminator: RepeatScheduleDiscriminator = RepeatScheduleDiscriminator.RepeatWeekly
  }

  final case class Rounding(
    `type`: io.flow.common.v0.models.RoundingType,
    method: io.flow.common.v0.models.RoundingMethod,
    value: BigDecimal
  )

  /**
   * Represents operating calendar and holidays of a center
   *
   * @param calendar Operating calendar used by origin center for shipment, if available. If not
   *        provided, assume they are never open.
   * @param holiday Standard holiday set to respect for this schedule
   * @param exception Holiday calendar used by origin center for shipment, if available.
   * @param cutoff Daily cutoff time for shipment fulfillment at origin center, if available.
   *        24-hour time
   * @param minLeadTime Optional number of days a center takes to make a shipment
   * @param maxLeadTime Optional number of days a center takes to make a shipment
   */

  final case class Schedule(
    calendar: _root_.scala.Option[io.flow.common.v0.models.Calendar] = None,
    holiday: io.flow.common.v0.models.HolidayCalendar,
    exception: Seq[io.flow.common.v0.models.Exception],
    cutoff: _root_.scala.Option[String] = None,
    minLeadTime: _root_.scala.Option[Long] = None,
    maxLeadTime: _root_.scala.Option[Long] = None
  )

  final case class SessionReference(
    id: String
  )

  /**
   * Represents a single user in the system
   *
   * @param email If known, the user's primary email address. While in most common cases, we
   *        expect users to have email addresses, there are edge cases where it is useful to
   *        allow a user to NOT have an email address. For example, users interacting solely
   *        from mobile devices, guest user accounts, initial onboarding where email is not
   *        known, etc. We think by starting off with an optional primary email address we
   *        can support these use cases with very little implementation cost.
   * @param name The user's name.
   * @param status Only active users are authorized to login and interact with the Flow platform.
   */

  final case class User(
    override val id: String,
    email: _root_.scala.Option[String] = None,
    name: io.flow.common.v0.models.Name,
    status: io.flow.common.v0.models.UserStatus = io.flow.common.v0.models.UserStatus.Active
  ) extends ExpandableUser {
    override val expandableUserDiscriminator: ExpandableUserDiscriminator = ExpandableUserDiscriminator.User
  }

  final case class UserReference(
    override val id: String
  ) extends ExpandableUser {
    override val expandableUserDiscriminator: ExpandableUserDiscriminator = ExpandableUserDiscriminator.UserReference
  }

  /**
   * @param postals Group of postal code prefixes included in this zone
   * @param provinces Group of provinces included in this zone. Values should in ISO 3166-2 province
   *        code format.
   * @param country The ISO 3166-3 country code. Case insensitive. See
   *        https://api.flow.io/reference/countries
   */

  final case class Zone(
    postals: _root_.scala.Option[Seq[String]] = None,
    provinces: _root_.scala.Option[Seq[String]] = None,
    country: String
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union DiscountOffer, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class DiscountOfferUndefinedType(
    description: String
  ) extends DiscountOffer {
    override val discountOfferDiscriminator: DiscountOfferDiscriminator = DiscountOfferDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableOrganization, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class ExpandableOrganizationUndefinedType(
    description: String
  ) extends ExpandableOrganization {
    override val expandableOrganizationDiscriminator: ExpandableOrganizationDiscriminator = ExpandableOrganizationDiscriminator.UNDEFINED(description)
    override def id: String = ???
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableUser, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class ExpandableUserUndefinedType(
    description: String
  ) extends ExpandableUser {
    override val expandableUserDiscriminator: ExpandableUserDiscriminator = ExpandableUserDiscriminator.UNDEFINED(description)
    override def id: String = ???
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union InputSpecificationLimitation, it will need to be handled in the
   * client code. This implementation will deserialize these future types as an
   * instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class InputSpecificationLimitationUndefinedType(
    description: String
  ) extends InputSpecificationLimitation {
    override val inputSpecificationLimitationDiscriminator: InputSpecificationLimitationDiscriminator = InputSpecificationLimitationDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union LogoImage, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class LogoImageUndefinedType(
    description: String
  ) extends LogoImage {
    override val logoImageDiscriminator: LogoImageDiscriminator = LogoImageDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union PriceSource, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class PriceSourceUndefinedType(
    description: String
  ) extends PriceSource {
    override val priceSourceDiscriminator: PriceSourceDiscriminator = PriceSourceDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union RepeatSchedule, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class RepeatScheduleUndefinedType(
    description: String
  ) extends RepeatSchedule {
    override val repeatScheduleDiscriminator: RepeatScheduleDiscriminator = RepeatScheduleDiscriminator.UNDEFINED(description)
  }
  /**
   * Used to tag attributes with a data type so they are properly validated.
   */
  sealed trait AttributeDataType extends _root_.scala.Product with _root_.scala.Serializable

  object AttributeDataType {

    /**
     * Boolean true/false data type
     */
    case object Boolean extends AttributeDataType {
      override def toString = "boolean"
    }
    /**
     * Value of the attribute must be an integer
     */
    case object Integer extends AttributeDataType {
      override def toString = "integer"
    }
    /**
     * Decimal datatype without size or precision restrictions. Commonly used for
     * currency values.
     */
    case object Decimal extends AttributeDataType {
      override def toString = "decimal"
    }
    /**
     * Unvalidated string of characters.
     */
    case object String extends AttributeDataType {
      override def toString = "string"
    }
    /**
     * An example ["Cotton", "Wool"]
     */
    case object JsonArray extends AttributeDataType {
      override def toString = "json_array"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AttributeDataType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AttributeDataType] = scala.List(Boolean, Integer, Decimal, String, JsonArray)

    private[this]
    val byName: Map[String, AttributeDataType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AttributeDataType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AttributeDataType] = byName.get(value.toLowerCase)

  }

  sealed trait AvailabilityStatus extends _root_.scala.Product with _root_.scala.Serializable

  object AvailabilityStatus {

    case object Enabled extends AvailabilityStatus { override def toString = "enabled" }
    case object Disabled extends AvailabilityStatus { override def toString = "disabled" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AvailabilityStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AvailabilityStatus] = scala.List(Enabled, Disabled)

    private[this]
    val byName: Map[String, AvailabilityStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AvailabilityStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AvailabilityStatus] = byName.get(value.toLowerCase)

  }

  sealed trait Calendar extends _root_.scala.Product with _root_.scala.Serializable

  object Calendar {

    /**
     * Mon - Fri
     */
    case object Weekdays extends Calendar { override def toString = "weekdays" }
    /**
     * 7 days per week
     */
    case object Everyday extends Calendar { override def toString = "everyday" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Calendar

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Calendar] = scala.List(Weekdays, Everyday)

    private[this]
    val byName: Map[String, Calendar] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Calendar = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Calendar] = byName.get(value.toLowerCase)

  }

  sealed trait Capability extends _root_.scala.Product with _root_.scala.Serializable

  object Capability {

    case object Crossdock extends Capability { override def toString = "crossdock" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Capability

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Capability] = scala.List(Crossdock)

    private[this]
    val byName: Map[String, Capability] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Capability = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Capability] = byName.get(value.toLowerCase)

  }

  sealed trait ChangeType extends _root_.scala.Product with _root_.scala.Serializable

  object ChangeType {

    case object Insert extends ChangeType { override def toString = "insert" }
    case object Update extends ChangeType { override def toString = "update" }
    case object Delete extends ChangeType { override def toString = "delete" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ChangeType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ChangeType] = scala.List(Insert, Update, Delete)

    private[this]
    val byName: Map[String, ChangeType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ChangeType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ChangeType] = byName.get(value.toLowerCase)

  }

  /**
   * A currency label formatter accepts a price label and updates it according to a
   * set of rules.
   */
  sealed trait CurrencyLabelFormatter extends _root_.scala.Product with _root_.scala.Serializable

  object CurrencyLabelFormatter {

    /**
     * If a price ends in '.00' or ',00', we remove the cents and just display the
     * price as a whole number. e.g. 'A$100.00' becomes 'A$100'
     */
    case object StripTrailingZeros extends CurrencyLabelFormatter {
      override def toString = "strip_trailing_zeros"
    }
    /**
     * Indicates that a currency symbol should appear as a prefix to the price label.
     * e.g $100
     */
    case object SymbolPrefix extends CurrencyLabelFormatter {
      override def toString = "symbol_prefix"
    }
    /**
     * Indicates that a currency symbol should appear as a suffix to the price label.
     * e.g 100 $
     */
    case object SymbolSuffix extends CurrencyLabelFormatter {
      override def toString = "symbol_suffix"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CurrencyLabelFormatter

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CurrencyLabelFormatter] = scala.List(StripTrailingZeros, SymbolPrefix, SymbolSuffix)

    private[this]
    val byName: Map[String, CurrencyLabelFormatter] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CurrencyLabelFormatter = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CurrencyLabelFormatter] = byName.get(value.toLowerCase)

  }

  /**
   * The currency symbol format controls which set of currency symbols we use when
   * displaying currencies
   */
  sealed trait CurrencySymbolFormat extends _root_.scala.Product with _root_.scala.Serializable

  object CurrencySymbolFormat {

    /**
     * The narrow format refers to the Unicode Common Locale Data Repository (CLDR)
     * 'narrow' symbols (e.g. '$' for CAD and AUD)
     */
    case object Narrow extends CurrencySymbolFormat {
      override def toString = "narrow"
    }
    /**
     * The primary format refers to the Unicode Common Locale Data Repository (CLDR)
     * 'primary' symbols (e.g. 'CA$' for CAD and 'A$' for AUD)
     */
    case object Primary extends CurrencySymbolFormat {
      override def toString = "primary"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CurrencySymbolFormat

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CurrencySymbolFormat] = scala.List(Narrow, Primary)

    private[this]
    val byName: Map[String, CurrencySymbolFormat] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CurrencySymbolFormat = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CurrencySymbolFormat] = byName.get(value.toLowerCase)

  }

  sealed trait DayOfWeek extends _root_.scala.Product with _root_.scala.Serializable

  object DayOfWeek {

    case object Sunday extends DayOfWeek { override def toString = "sunday" }
    case object Monday extends DayOfWeek { override def toString = "monday" }
    case object Tuesday extends DayOfWeek { override def toString = "tuesday" }
    case object Wednesday extends DayOfWeek { override def toString = "wednesday" }
    case object Thursday extends DayOfWeek { override def toString = "thursday" }
    case object Friday extends DayOfWeek { override def toString = "friday" }
    case object Saturday extends DayOfWeek { override def toString = "saturday" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DayOfWeek

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DayOfWeek] = scala.List(Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday)

    private[this]
    val byName: Map[String, DayOfWeek] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DayOfWeek = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DayOfWeek] = byName.get(value.toLowerCase)

  }

  sealed trait DeliveredDuty extends _root_.scala.Product with _root_.scala.Serializable

  object DeliveredDuty {

    /**
     * Delivered Duty Paid (DDP). See https://en.wikipedia.org/wiki/Incoterms for more
     * information
     */
    case object Paid extends DeliveredDuty {
      override def toString = "paid"
    }
    /**
     * Delivered Duty Unpaid (DDU). See https://en.wikipedia.org/wiki/Incoterms for
     * more information
     */
    case object Unpaid extends DeliveredDuty {
      override def toString = "unpaid"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DeliveredDuty

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DeliveredDuty] = scala.List(Paid, Unpaid)

    private[this]
    val byName: Map[String, DeliveredDuty] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DeliveredDuty = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DeliveredDuty] = byName.get(value.toLowerCase)

  }

  sealed trait DiscountTarget extends _root_.scala.Product with _root_.scala.Serializable

  object DiscountTarget {

    /**
     * Discount is targeted to an item.
     */
    case object Item extends DiscountTarget { override def toString = "item" }
    /**
     * Discount is targeting to shipping. Only applicable if the discount is provided
     * at the order level.
     */
    case object Shipping extends DiscountTarget {
      override def toString = "shipping"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DiscountTarget

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DiscountTarget] = scala.List(Item, Shipping)

    private[this]
    val byName: Map[String, DiscountTarget] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DiscountTarget = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DiscountTarget] = byName.get(value.toLowerCase)

  }

  sealed trait EntityIdentifierType extends _root_.scala.Product with _root_.scala.Serializable

  object EntityIdentifierType {

    /**
     * The Import One-Stop Shop (IOSS) to comply with VAT on imported goods. see:
     * https://ec.europa.eu/taxation_customs/business/vat/ioss_en
     */
    case object Ioss extends EntityIdentifierType {
      override def toString = "ioss"
    }
    /**
     * The VAT on Electronic Commerce (VOEC) to comply with VAT on imported goods. see:
     * https://www.skatteetaten.no/globalassets/bedrift-og-organisasjon/voec/voec-guidelines-20200807.pdf
     */
    case object Voec extends EntityIdentifierType {
      override def toString = "voec"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends EntityIdentifierType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[EntityIdentifierType] = scala.List(Ioss, Voec)

    private[this]
    val byName: Map[String, EntityIdentifierType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): EntityIdentifierType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[EntityIdentifierType] = byName.get(value.toLowerCase)

  }

  sealed trait Environment extends _root_.scala.Product with _root_.scala.Serializable

  object Environment {

    /**
     * In sandbox, no external services (e.g. orders, payments, logistics) will
     * generate real transactions
     */
    case object Sandbox extends Environment {
      override def toString = "sandbox"
    }
    /**
     * In production, all external services are live and will generate real
     * transactions
     */
    case object Production extends Environment {
      override def toString = "production"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Environment

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Environment] = scala.List(Sandbox, Production)

    private[this]
    val byName: Map[String, Environment] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Environment = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Environment] = byName.get(value.toLowerCase)

  }

  sealed trait ExceptionType extends _root_.scala.Product with _root_.scala.Serializable

  object ExceptionType {

    case object Open extends ExceptionType { override def toString = "open" }
    case object Closed extends ExceptionType { override def toString = "closed" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ExceptionType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ExceptionType] = scala.List(Open, Closed)

    private[this]
    val byName: Map[String, ExceptionType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExceptionType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExceptionType] = byName.get(value.toLowerCase)

  }

  /**
   * Defines how goods will be supplied to a customer from a distribution center (DC)
   * from the perspective of the type of border being crossed.
   */
  sealed trait GoodsSupply extends _root_.scala.Product with _root_.scala.Serializable

  object GoodsSupply {

    /**
     * Goods will be supplied from a DC from outside the national and customs
     * boundaries of the destination.
     */
    case object Export extends GoodsSupply {
      override def toString = "export"
    }
    /**
     * Goods will be supplied from a DC outside the national boundries of the
     * destination, but within the same customs union.
     */
    case object IntraCommunity extends GoodsSupply {
      override def toString = "intra_community"
    }
    /**
     * Goods will be supplied from a DC within the same country as the destination.
     */
    case object Local extends GoodsSupply {
      override def toString = "local"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends GoodsSupply

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[GoodsSupply] = scala.List(Export, IntraCommunity, Local)

    private[this]
    val byName: Map[String, GoodsSupply] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): GoodsSupply = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[GoodsSupply] = byName.get(value.toLowerCase)

  }

  sealed trait HolidayCalendar extends _root_.scala.Product with _root_.scala.Serializable

  object HolidayCalendar {

    case object UsBankHolidays extends HolidayCalendar { override def toString = "us_bank_holidays" }
    case object JewishHolidays extends HolidayCalendar { override def toString = "jewish_holidays" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends HolidayCalendar

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[HolidayCalendar] = scala.List(UsBankHolidays, JewishHolidays)

    private[this]
    val byName: Map[String, HolidayCalendar] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): HolidayCalendar = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[HolidayCalendar] = byName.get(value.toLowerCase)

  }

  /**
   * The key of each possible localized price note is defined here.
   */
  sealed trait IncludedLevyKey extends _root_.scala.Product with _root_.scala.Serializable

  object IncludedLevyKey {

    case object Duty extends IncludedLevyKey { override def toString = "duty" }
    case object Vat extends IncludedLevyKey { override def toString = "vat" }
    case object VatAndDuty extends IncludedLevyKey { override def toString = "vat_and_duty" }
    case object None extends IncludedLevyKey { override def toString = "none" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends IncludedLevyKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[IncludedLevyKey] = scala.List(Duty, Vat, VatAndDuty, None)

    private[this]
    val byName: Map[String, IncludedLevyKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): IncludedLevyKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[IncludedLevyKey] = byName.get(value.toLowerCase)

  }

  /**
   * International Commercial Terms are a series of pre-defined commercial terms
   * published by the International Chamber of Commerce (ICC) relating to
   * international commercial law.
   */
  sealed trait Incoterm extends _root_.scala.Product with _root_.scala.Serializable

  object Incoterm {

    /**
     * Ex Works (named place of delivery)
     */
    case object Exw extends Incoterm { override def toString = "EXW" }
    /**
     * Free Carrier (named place of delivery)
     */
    case object Fca extends Incoterm { override def toString = "FCA" }
    /**
     * Carriage Paid To (named place of destination)
     */
    case object Cpt extends Incoterm {
      override def toString = "CPT"
    }
    /**
     * Carriage and Insurance Paid to (named place of destination)
     */
    case object Cip extends Incoterm {
      override def toString = "CIP"
    }
    /**
     * Delivered At Terminal (named terminal at port or place of destination)
     */
    case object Dat extends Incoterm {
      override def toString = "DAT"
    }
    /**
     * Delivered At Place (named place of destination)
     */
    case object Dap extends Incoterm {
      override def toString = "DAP"
    }
    /**
     * Delivered Duty Paid (named place of destination)
     */
    case object Ddp extends Incoterm {
      override def toString = "DDP"
    }
    /**
     * Free Alongside Ship (named port of shipment)
     */
    case object Fas extends Incoterm {
      override def toString = "FAS"
    }
    /**
     * Free on Board (named port of shipment)
     */
    case object Fob extends Incoterm { override def toString = "FOB" }
    /**
     * Cost and Freight (named port of destination)
     */
    case object Cfr extends Incoterm {
      override def toString = "CFR"
    }
    /**
     * Cost, Insurance & Freight (named port of destination)
     */
    case object Cif extends Incoterm {
      override def toString = "CIF"
    }
    /**
     * Delivered at Frontier (named place of delivery)
     */
    case object Daf extends Incoterm {
      override def toString = "DAF"
    }
    /**
     * Delivered Ex Ship
     */
    case object Des extends Incoterm { override def toString = "DES" }
    /**
     * Delivered Ex Quay (named port of delivery)
     */
    case object Deq extends Incoterm { override def toString = "DEQ" }
    /**
     * Delivered Duty Unpaid (named place of destination)
     */
    case object Ddu extends Incoterm {
      override def toString = "DDU"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Incoterm

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Incoterm] = scala.List(Exw, Fca, Cpt, Cip, Dat, Dap, Ddp, Fas, Fob, Cfr, Cif, Daf, Des, Deq, Ddu)

    private[this]
    val byName: Map[String, Incoterm] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Incoterm = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Incoterm] = byName.get(value.toLowerCase)

  }

  sealed trait InputSpecificationType extends _root_.scala.Product with _root_.scala.Serializable

  object InputSpecificationType {

    case object Text extends InputSpecificationType { override def toString = "text" }
    case object Number extends InputSpecificationType { override def toString = "number" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends InputSpecificationType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[InputSpecificationType] = scala.List(Text, Number)

    private[this]
    val byName: Map[String, InputSpecificationType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): InputSpecificationType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[InputSpecificationType] = byName.get(value.toLowerCase)

  }

  /**
   * Either a fixed or percent adjustment applied to some amount.
   */
  sealed trait MarginType extends _root_.scala.Product with _root_.scala.Serializable

  object MarginType {

    /**
     * A fixed amount to add, e.g 2.5 would add an absolute margin of 2.5 in the base
     * currency of your item.
     */
    case object Fixed extends MarginType {
      override def toString = "fixed"
    }
    /**
     * A percent of the base cost to add, e.g. 1.2 would represent a 1.2% increase.
     */
    case object Percent extends MarginType {
      override def toString = "percent"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends MarginType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[MarginType] = scala.List(Fixed, Percent)

    private[this]
    val byName: Map[String, MarginType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): MarginType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[MarginType] = byName.get(value.toLowerCase)

  }

  sealed trait MeasurementSystem extends _root_.scala.Product with _root_.scala.Serializable

  object MeasurementSystem {

    case object Imperial extends MeasurementSystem { override def toString = "imperial" }
    case object Metric extends MeasurementSystem { override def toString = "metric" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends MeasurementSystem

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[MeasurementSystem] = scala.List(Imperial, Metric)

    private[this]
    val byName: Map[String, MeasurementSystem] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): MeasurementSystem = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[MeasurementSystem] = byName.get(value.toLowerCase)

  }

  /**
   * The merchant of record enum defines who is merchant of record for a particular
   * transaction - either Flow is serving as the merchant of record or the
   * organization is serving as merchant of record.
   */
  sealed trait MerchantOfRecord extends _root_.scala.Product with _root_.scala.Serializable

  object MerchantOfRecord {

    case object Flow extends MerchantOfRecord { override def toString = "flow" }
    case object Organization extends MerchantOfRecord { override def toString = "organization" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends MerchantOfRecord

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[MerchantOfRecord] = scala.List(Flow, Organization)

    private[this]
    val byName: Map[String, MerchantOfRecord] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): MerchantOfRecord = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[MerchantOfRecord] = byName.get(value.toLowerCase)

  }

  /**
   * The order merchant of record defines who is merchant of record for a particular
   * order. The value will be 'mixed' if you support split payments and the merchant
   * of record differed across the individual payment transactions.
   */
  sealed trait OrderMerchantOfRecord extends _root_.scala.Product with _root_.scala.Serializable

  object OrderMerchantOfRecord {

    case object Flow extends OrderMerchantOfRecord { override def toString = "flow" }
    case object Organization extends OrderMerchantOfRecord { override def toString = "organization" }
    case object Mixed extends OrderMerchantOfRecord { override def toString = "mixed" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderMerchantOfRecord

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderMerchantOfRecord] = scala.List(Flow, Organization, Mixed)

    private[this]
    val byName: Map[String, OrderMerchantOfRecord] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderMerchantOfRecord = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderMerchantOfRecord] = byName.get(value.toLowerCase)

  }

  sealed trait OrganizationStatus extends _root_.scala.Product with _root_.scala.Serializable

  object OrganizationStatus {

    case object Active extends OrganizationStatus { override def toString = "active" }
    /**
     * Determined by usage: ex: orders placed, experience updated, catalog items
     * updated, etc...
     */
    case object Inactive extends OrganizationStatus {
      override def toString = "inactive"
    }
    /**
     * Manually deactivated
     */
    case object Deactivated extends OrganizationStatus {
      override def toString = "deactivated"
    }
    /**
     * Created but not ready for transactions.
     */
    case object Provisioned extends OrganizationStatus {
      override def toString = "provisioned"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrganizationStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrganizationStatus] = scala.List(Active, Inactive, Deactivated, Provisioned)

    private[this]
    val byName: Map[String, OrganizationStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrganizationStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrganizationStatus] = byName.get(value.toLowerCase)

  }

  sealed trait PriceBookStatus extends _root_.scala.Product with _root_.scala.Serializable

  object PriceBookStatus {

    case object Draft extends PriceBookStatus { override def toString = "draft" }
    case object Published extends PriceBookStatus { override def toString = "published" }
    case object Archived extends PriceBookStatus { override def toString = "archived" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PriceBookStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PriceBookStatus] = scala.List(Draft, Published, Archived)

    private[this]
    val byName: Map[String, PriceBookStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PriceBookStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PriceBookStatus] = byName.get(value.toLowerCase)

  }

  /**
   * A user's role within an organization
   */
  sealed trait Role extends _root_.scala.Product with _root_.scala.Serializable

  object Role {

    case object Admin extends Role { override def toString = "admin" }
    case object Member extends Role { override def toString = "member" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Role

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Role] = scala.List(Admin, Member)

    private[this]
    val byName: Map[String, Role] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Role = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Role] = byName.get(value.toLowerCase)

  }

  /**
   * Direction to round localized price
   */
  sealed trait RoundingMethod extends _root_.scala.Product with _root_.scala.Serializable

  object RoundingMethod {

    /**
     * Round up to the specified rounding.value
     */
    case object Up extends RoundingMethod {
      override def toString = "up"
    }
    /**
     * Round down to the specified rounding.value
     */
    case object Down extends RoundingMethod {
      override def toString = "down"
    }
    /**
     * Round to the nearest specified rounding.value. If equidistant, will round up.
     */
    case object Nearest extends RoundingMethod {
      override def toString = "nearest"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends RoundingMethod

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[RoundingMethod] = scala.List(Up, Down, Nearest)

    private[this]
    val byName: Map[String, RoundingMethod] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): RoundingMethod = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[RoundingMethod] = byName.get(value.toLowerCase)

  }

  /**
   * Rounding type determines the rule used to enforce rounding. Common rules will
   * ensure that the final price ends w/ a given number (e.g. ends with .95) or is a
   * multiple of some number (multiples of 5 or 10 are common).
   */
  sealed trait RoundingType extends _root_.scala.Product with _root_.scala.Serializable

  object RoundingType {

    /**
     * Rounds a value to an amount ending with a pattern, e.g. an amount ending in
     * '.99'.
     */
    case object Pattern extends RoundingType {
      override def toString = "pattern"
    }
    /**
     * Rounds a value to an amount that is the multiple of a value, e.g. rounding to
     * the nearest 5 would ensure that the resulting number ends in either 0 or 5.
     */
    case object Multiple extends RoundingType {
      override def toString = "multiple"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends RoundingType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[RoundingType] = scala.List(Pattern, Multiple)

    private[this]
    val byName: Map[String, RoundingType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): RoundingType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[RoundingType] = byName.get(value.toLowerCase)

  }

  sealed trait ScheduleExceptionStatus extends _root_.scala.Product with _root_.scala.Serializable

  object ScheduleExceptionStatus {

    case object Open extends ScheduleExceptionStatus { override def toString = "Open" }
    case object Closed extends ScheduleExceptionStatus { override def toString = "Closed" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ScheduleExceptionStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ScheduleExceptionStatus] = scala.List(Open, Closed)

    private[this]
    val byName: Map[String, ScheduleExceptionStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ScheduleExceptionStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ScheduleExceptionStatus] = byName.get(value.toLowerCase)

  }

  sealed trait SortDirection extends _root_.scala.Product with _root_.scala.Serializable

  object SortDirection {

    case object Ascending extends SortDirection { override def toString = "ascending" }
    case object Descending extends SortDirection { override def toString = "descending" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends SortDirection

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[SortDirection] = scala.List(Ascending, Descending)

    private[this]
    val byName: Map[String, SortDirection] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): SortDirection = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[SortDirection] = byName.get(value.toLowerCase)

  }

  /**
   * Defines the units of measurement that we support. As units are added, we conform
   * with the standard units provided by jscience as part of JSR 363 - see
   * http://jscience.org/api/javax/measure/unit/SI.html and
   * http://jscience.org/api/javax/measure/unit/NonSI.html
   */
  sealed trait UnitOfMeasurement extends _root_.scala.Product with _root_.scala.Serializable

  object UnitOfMeasurement {

    /**
     * Equivalent to MILLI(METRE).
     */
    case object Millimeter extends UnitOfMeasurement {
      override def toString = "millimeter"
    }
    /**
     * Equivalent to CENTI(METRE).
     */
    case object Centimeter extends UnitOfMeasurement {
      override def toString = "centimeter"
    }
    /**
     * A unit of length equal to 0.0254 m (standard name in).
     */
    case object Inch extends UnitOfMeasurement {
      override def toString = "inch"
    }
    /**
     * A unit of length equal to 0.3048 m (standard name ft).
     */
    case object Foot extends UnitOfMeasurement {
      override def toString = "foot"
    }
    /**
     * A unit of volume equal to one cubic inch (in).
     */
    case object CubicInch extends UnitOfMeasurement {
      override def toString = "cubic_inch"
    }
    /**
     * The metric unit for volume quantities (m).
     */
    case object CubicMeter extends UnitOfMeasurement {
      override def toString = "cubic_meter"
    }
    /**
     * A unit of mass equal to 1 / 1000 kilogram (standard name g).
     */
    case object Gram extends UnitOfMeasurement {
      override def toString = "gram"
    }
    /**
     * The base unit for mass quantities (kg).
     */
    case object Kilogram extends UnitOfMeasurement {
      override def toString = "kilogram"
    }
    /**
     * The base unit for length quantities (m).
     */
    case object Meter extends UnitOfMeasurement {
      override def toString = "meter"
    }
    /**
     * A unit of mass equal to 1 / 16 POUND (standard name oz).
     */
    case object Ounce extends UnitOfMeasurement {
      override def toString = "ounce"
    }
    /**
     * A unit of mass equal to 453.59237 grams (avoirdupois pound, standard name lb).
     */
    case object Pound extends UnitOfMeasurement {
      override def toString = "pound"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends UnitOfMeasurement

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[UnitOfMeasurement] = scala.List(Millimeter, Centimeter, Inch, Foot, CubicInch, CubicMeter, Gram, Kilogram, Meter, Ounce, Pound)

    private[this]
    val byName: Map[String, UnitOfMeasurement] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): UnitOfMeasurement = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[UnitOfMeasurement] = byName.get(value.toLowerCase)

  }

  /**
   * Defines the units of time that we support
   */
  sealed trait UnitOfTime extends _root_.scala.Product with _root_.scala.Serializable

  object UnitOfTime {

    case object Year extends UnitOfTime { override def toString = "year" }
    case object Month extends UnitOfTime { override def toString = "month" }
    case object Week extends UnitOfTime { override def toString = "week" }
    case object Day extends UnitOfTime { override def toString = "day" }
    case object Hour extends UnitOfTime { override def toString = "hour" }
    case object Minute extends UnitOfTime { override def toString = "minute" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends UnitOfTime

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[UnitOfTime] = scala.List(Year, Month, Week, Day, Hour, Minute)

    private[this]
    val byName: Map[String, UnitOfTime] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): UnitOfTime = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[UnitOfTime] = byName.get(value.toLowerCase)

  }

  /**
   * The status of the user account. Valid transitions are from pending -> active,
   * active -> inactive, inactive -> active
   */
  sealed trait UserStatus extends _root_.scala.Product with _root_.scala.Serializable

  object UserStatus {

    /**
     * Represents a new user account that is pending approval
     */
    case object Pending extends UserStatus {
      override def toString = "pending"
    }
    /**
     * Represents an active user account - can authenticate with this account
     */
    case object Active extends UserStatus {
      override def toString = "active"
    }
    /**
     * Represents an inactive user account - can no longer authenticate with this
     * account
     */
    case object Inactive extends UserStatus {
      override def toString = "inactive"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends UserStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[UserStatus] = scala.List(Pending, Active, Inactive)

    private[this]
    val byName: Map[String, UserStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): UserStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[UserStatus] = byName.get(value.toLowerCase)

  }

  sealed trait ValueAddedService extends _root_.scala.Product with _root_.scala.Serializable

  object ValueAddedService {

    /**
     * See https://en.wikipedia.org/wiki/ORM-D
     */
    case object HazardousMaterial extends ValueAddedService {
      override def toString = "Hazardous Material"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ValueAddedService

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ValueAddedService] = scala.List(HazardousMaterial)

    private[this]
    val byName: Map[String, ValueAddedService] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ValueAddedService = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ValueAddedService] = byName.get(value.toLowerCase)

  }

  sealed trait Visibility extends _root_.scala.Product with _root_.scala.Serializable

  object Visibility {

    case object Public extends Visibility { override def toString = "public" }
    case object Private extends Visibility { override def toString = "private" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Visibility

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Visibility] = scala.List(Public, Private)

    private[this]
    val byName: Map[String, Visibility] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Visibility = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Visibility] = byName.get(value.toLowerCase)

  }

}